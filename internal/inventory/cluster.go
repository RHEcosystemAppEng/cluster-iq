package inventory

import (
	"fmt"
	"slices"
	"time"
)

// Cluster is the object to store Openshift Clusters and its properties
type Cluster struct {
	// ClusterID is the unique key to identify every cluster independently of which account it belongs.
	// Its built as "cluster_name+infra_id". Must be unique per Account.
	ClusterID string `db:"cluster_id"`

	// ClusterName is the cluster name defined when it was created. It can be repeated in case that the same cluster definition was used multiple times, but will appear with different InfraID.
	ClusterName string `db:"cluster_name"`

	// InfraID is the infrastructure ID generated by openshift-installer during the installation.
	InfraID string `db:"infra_id"`

	// Provider identifies the cloud/infrastructure provider.
	Provider Provider `db:"provider"`

	// Status defines the status of the cluster if its infrastructure is running or not or it was removed (Terminated).
	Status ResourceStatus `db:"status"`

	// Region where the cluster is deployed. Currently only a single region is supported.
	Region string `db:"region"`

	// AccountID which this cluster belongs to.
	AccountID string `db:"account_id"`

	// Openshift Console URL. Might not be accessible if its protected.
	ConsoleLink string `db:"console_link"`

	// LastScanTS is the timestamp when the cluster was scanned for the last time.
	LastScanTS time.Time `db:"last_scan_ts"`

	// CreatedAt is the timestamp when the cluster was created (from the inventory point of view, not from the provider).
	CreatedAt time.Time `db:"created_at"`

	// Age is the amount of days since the cluster was created.
	Age int `db:"age"`

	// Owner is the name of who created the cluster (Normally, extracted from instance tags).
	Owner string `db:"owner"`

	// In-memory fields (no saved on DB)
	// ===========================================================================

	// Instances list in the cluster
	Instances []Instance
}

// NewCluster creates a new cluster instance
func NewCluster(clusterName string, infraID string, provider Provider, region string, consoleLink string, owner string) *Cluster {
	if clusterName == "" {
		return nil
	}

	return &Cluster{
		ClusterID:   generateClusterID(clusterName, infraID),
		ClusterName: clusterName,
		InfraID:     infraID,
		Provider:    provider,
		Status:      Running,
		Region:      region,
		AccountID:   "",
		ConsoleLink: consoleLink,
		LastScanTS:  time.Time{},
		CreatedAt:   time.Now(),
		Age:         0,
		Owner:       owner,
		Instances:   make([]Instance, 0),
	}
}

// IsClusterStopped checks if the Cluster is Stopped
func (c Cluster) IsClusterStopped() bool {
	return c.Status == Stopped
}

// IsClusterRunning checks if the Cluster is Running
func (c Cluster) IsClusterRunning() bool {
	return c.Status == Running
}

// UpdateClusterInfo as a update function wrapper
func (c *Cluster) Update() error {
	var err error

	// Update Cluster Status
	c.UpdateStatus()

	// Update Cluster Age and CreatedAt
	if err = c.UpdateAge(); err != nil {
		return err
	}

	return nil
}

// UpdateAge updates cluster age based on the oldest instance creation timestamp. The cluster will be considered as old as the oldest instance
func (c *Cluster) UpdateAge() error {
	creationTS := time.Now()
	for _, instance := range c.Instances {
		if instance.CreatedAt.Before(creationTS) {
			creationTS = instance.CreatedAt
		}
	}
	c.CreatedAt = creationTS

	// Calculating Age in days since the cluster was created until last scraping
	newAge := calculateAge(c.CreatedAt, c.LastScanTS)
	if c.Age > newAge && c.Age != 0 {
		return fmt.Errorf("new cluster age is lower than previous value. Current age: %d, New estimated age: %d", c.Age, newAge)
	}

	c.Age = newAge
	return nil
}

// UpdateStatus evaluate the status of the cluster checking how many of the
// nodes are in Running, Stopped or Terminated status.
// Logic rules:
// - Empty cluster (no instances) -> Terminated
// - Any instance Running -> Running (early return)
// - All instances Terminated -> Terminated
// - Otherwise (mix of Stopped/Terminated or all Stopped) -> Stopped
func (c *Cluster) UpdateStatus() {
	instanceCount := len(c.Instances)

	// TODO. Possible edge case
	if instanceCount == 0 {
		c.Status = Terminated
		return
	}

	terminatedCount := 0
	for _, instance := range c.Instances {
		switch instance.Status {
		case Running:
			c.Status = Running
			return
		case Terminated:
			terminatedCount++
		}

	}

	if terminatedCount == instanceCount {
		c.Status = Terminated
	} else {
		c.Status = Stopped
	}
}

// IsInstanceInCluster checks if an instance is already in the Cluster
func (c Cluster) IsInstanceInCluster(instance *Instance) bool {
	return slices.ContainsFunc(c.Instances, func(i Instance) bool {
		return instance.InstanceID == i.InstanceID
	})
}

// AddInstance add a new instance to a cluster
func (c *Cluster) AddInstance(instance *Instance) error {
	if c.IsInstanceInCluster(instance) {
		return fmt.Errorf("Instance '%s[%s]' already exists in Cluster %s", instance.ClusterID, instance.InstanceID, c.ClusterName)
	}

	// Adding Instance
	instance.ClusterID = c.ClusterID
	c.Instances = append(c.Instances, *instance)
	return c.Update()
}

func (c *Cluster) DeleteInstance(instanceName string) error {
	for i, instance := range c.Instances {
		if instance.InstanceName == instanceName {
			c.Instances = append(c.Instances[:i], c.Instances[i+1:]...)
			return nil
		}
	}

	return fmt.Errorf("failed to delete Instance(%s) from Cluster(%s). Instance not found", instanceName, c.ClusterName)
}

func (c Cluster) InstancesCount() int {
	return len(c.Instances)
}

// Obtain the required parameters for generate a ClusterID. If any key parameter is missing, it will return a non-nil error
func generateClusterID(name string, infraID string) string {
	return name + "-" + infraID
}

// PrintCluster prints cluster info
func (c Cluster) PrintCluster() {
	fmt.Printf("\t\tCluster:[%s] -- Region: %s, Provider: %s, #Instances: %d\n", c.ClusterName, c.Region, c.Provider, c.InstancesCount())

	for _, instance := range c.Instances {
		instance.PrintInstance()
	}
}
