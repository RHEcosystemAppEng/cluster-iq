package inventory

import (
	"fmt"
	"strings"
	"time"
)

// Cluster is the object to store Openshift Clusters and its properties
type Cluster struct {
	// ID is the unique key to identify every cluster independently of which account it belongs
	// Its built as "name+infra_id+account"
	ID string `db:"id" json:"id"`

	// Cluster's Name. Must be unique per Account
	Name string `db:"name" json:"name"`

	// InfraID is the infrastructure ID generated by openshift-installer during the installation.Cluster (Could be undefined)
	InfraID string `db:"infra_id" json:"infra_id"`

	// Infrastructure provider identifier.
	Provider CloudProvider `db:"provider" json:"provider"`

	// Defines the status of the cluster if its infrastructure is running or not or it was removed
	Status InstanceStatus `db:"status" json:"status"`

	// The region of the infrastructure provider in which the cluster is deployed
	Region string `db:"region" json:"region"`

	// Account name which this cluster belongs to
	AccountName string `db:"account_name" json:"accountName"`

	// Openshift Console URL. Might not be accesible if its protected
	ConsoleLink string `db:"console_link" json:"consoleLink"`

	// Instances count
	InstanceCount int `db:"instance_count" json:"instanceCount"`

	// Last scan timestamp of the cluster
	LastScanTimestamp time.Time `db:"last_scan_timestamp" json:"lastScanTimestamp"`

	// Timestamp when the cluster was created
	CreationTimestamp time.Time `db:"creation_timestamp" json:"creationTimestamp"`

	// Amount of days since the cluster was created
	Age int `db:"age" json:"age"`

	// Cluster's owner
	Owner string `db:"owner" json:"owner"`

	// Total cost (US Dollars)
	TotalCost float64 `db:"total_cost" json:"totalCost"`

	// Cluster's instance (nodes) lists
	Instances []Instance
}

// NewCluster creates a new cluster instance
func NewCluster(name string, infraID string, provider CloudProvider, region string, accountName string, consoleLink string, owner string) *Cluster {
	id, err := GenerateClusterID(name, infraID, accountName)
	if err != nil {
		return nil
	}
	now := time.Now()

	return &Cluster{
		ID:                id,
		Name:              name,
		InfraID:           infraID,
		Provider:          provider,
		Status:            Running,
		Region:            region,
		AccountName:       accountName,
		ConsoleLink:       consoleLink,
		InstanceCount:     0,
		LastScanTimestamp: now,
		CreationTimestamp: now,
		Age:               calculateAge(now, now),
		Owner:             owner,
		TotalCost:         0.0,
		Instances:         make([]Instance, 0),
	}
}

// isClusterStopped checks if the Cluster is Stopped
func (c Cluster) isClusterStopped() bool {
	if c.Status == Stopped {
		return true
	}
	return false
}

// isClusterRunning checks if the Cluster is Running
func (c Cluster) isClusterRunning() bool {
	if c.Status == Running {
		return true
	}
	return false
}

// UpdateClusterInfo as a update function wrapper
func (c *Cluster) Update() error {
	var err error

	// Update Cluster Status
	c.UpdateStatus()

	// Update Cluster Age and CreationTimestamp
	if err = c.UpdateAge(); err != nil {
		return err
	}

	// Update Cluster Costs
	if err = c.UpdateCosts(); err != nil {
		return err
	}
	return nil
}

// UpdateAge updates cluster age based on current and creation timestamps
func (c *Cluster) UpdateAge() error {
	var creationTimestamp time.Time = time.Now()
	for _, instance := range c.Instances {
		if instance.CreationTimestamp.Before(creationTimestamp) {
			creationTimestamp = instance.CreationTimestamp
		}
	}
	c.CreationTimestamp = creationTimestamp

	// Calculating Age in days since the cluster was created until last scraping
	newAge := calculateAge(c.CreationTimestamp, c.LastScanTimestamp)
	if c.Age > newAge && c.Age != 0 {
		return fmt.Errorf("New cluster age is lower than previous value. Current age: %d, New estimated age: %d", c.Age, newAge)
	}

	c.Age = newAge
	return nil
}

// UpdateCosts takes every cluster's instance costs and estimates the total cost for the cluster
func (c *Cluster) UpdateCosts() error {
	var newCost float64

	newCost = 0.0
	for _, instance := range c.Instances {
		newCost += instance.TotalCost
	}

	if c.TotalCost < newCost {
		return fmt.Errorf("New estimated cost is lower than expected. Review the cluster/instances costs. Current Cost: %f, New estimated cost: %f", c.TotalCost, newCost)
	}

	c.TotalCost = newCost
	return nil
}

// UpdateStatus evaluate the status of the cluster checking how many of the
// nodes are in Running, Stopped or Terminated status.
// Logic rules:
// - Empty cluster (no instances) -> Terminated
// - Any instance Running -> Running (early return)
// - All instances Terminated -> Terminated
// - Otherwise (mix of Stopped/Terminated or all Stopped) -> Stopped
func (c *Cluster) UpdateStatus() {
	c.InstanceCount = len(c.Instances)

	// TODO. Possible edge case
	if c.InstanceCount == 0 {
		c.Status = Terminated
		return
	}

	terminatedCount := 0

	for _, instance := range c.Instances {
		if instance.Status == Running {
			c.Status = Running
			return
		} else if instance.Status == Terminated {
			terminatedCount++
		}
	}

	if terminatedCount == c.InstanceCount {
		c.Status = Terminated
	} else {
		c.Status = Stopped
	}
}

// AddInstance add a new instance to a cluster
func (c *Cluster) AddInstance(instance Instance) error {
	c.Instances = append(c.Instances, instance)
	return c.Update()
}

// Obtain the required parameters for generate a ClusterID. If any key parameter is missing, it will return a non-nil error
func GenerateClusterID(name string, infraID string, accountName string) (string, error) {
	if name == "" || accountName == "" {
		return "", fmt.Errorf("Can't generate ClusterID. Some key parameters are missing")
	}
	args := []string{name, infraID, accountName}
	id := strings.Join(args, "-")
	return id, nil
}

// PrintCluster prints cluster info
func (c Cluster) PrintCluster() {
	fmt.Printf("\t\tCluster: %s[%s] -- Region: %s, Provider: %s, #Instances: %d\n", c.Name, c.ID, c.Region, c.Provider, len(c.Instances))

	for _, instance := range c.Instances {
		instance.PrintInstance()
	}
}
