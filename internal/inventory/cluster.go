package inventory

import (
	"fmt"
	"slices"
	"time"
)

// Cluster is the object to store Openshift Clusters and its properties
type Cluster struct {
	ClusterID   string         `db:"cluster_id"`   // clusterName + InfraID
	ClusterName string         `db:"cluster_name"` // Cluster's Name. Must be unique per Account
	InfraID     string         `db:"infra_id"`     // InfraID is the infrastructure ID generated by openshift-installer during the installation.Cluster (Could be undefined)
	Provider    CloudProvider  `db:"provider"`     // Infrastructure provider identifier.
	Status      ResourceStatus `db:"status"`       // Defines the status of the cluster if its infrastructure is running or not or it was removed
	Region      string         `db:"region"`       // The region of the infrastructure provider in which the cluster is deployed
	AccountID   int            `db:"account_id"`   // Account ID which this cluster belongs to
	ConsoleLink string         `db:"console_link"` // Openshift Console URL. Might not be accesible if its protected
	LastScanTS  time.Time      `db:"last_scan_ts"` // Last scan timestamp of the cluster
	CreatedAt   time.Time      `db:"created_at"`   // Timestamp when the cluster was created
	Age         int            `db:"age"`          // Amount of days since the cluster was created
	Owner       string         `db:"owner"`        // Cluster's owner

	// In-memory fields (not saved on DB)
	Account   *Account
	Instances []Instance // Cluster's instance (nodes) lists
}

// NewCluster creates a new cluster instance
func NewCluster(clusterName string, infraID string, provider CloudProvider, region string, consoleLink string, owner string) *Cluster {
	return &Cluster{
		ClusterID:   generateClusterID(clusterName, infraID),
		ClusterName: clusterName,
		InfraID:     infraID,
		Provider:    provider,
		Status:      Running,
		Region:      region,
		AccountID:   0,
		ConsoleLink: consoleLink,
		LastScanTS:  time.Time{},
		CreatedAt:   time.Now(),
		Age:         0,
		Owner:       owner,
		Account:     nil,
		Instances:   make([]Instance, 0),
	}
}

// IsClusterStopped checks if the Cluster is Stopped
func (c Cluster) IsClusterStopped() bool {
	if c.Status == Stopped {
		return true
	}
	return false
}

// IsClusterRunning checks if the Cluster is Running
func (c Cluster) IsClusterRunning() bool {
	if c.Status == Running {
		return true
	}
	return false
}

// UpdateClusterInfo as a update function wrapper
func (c *Cluster) Update() error {
	var err error

	// Update Cluster Status
	c.UpdateStatus()

	// Update Cluster Age and CreatedAt
	if err = c.UpdateAge(); err != nil {
		return err
	}

	return nil
}

// UpdateAge updates cluster age based on current and creation timestamps
func (c *Cluster) UpdateAge() error {
	var creationTS time.Time = time.Now()
	for _, instance := range c.Instances {
		if instance.CreatedAt.Before(creationTS) {
			creationTS = instance.CreatedAt
		}
	}
	c.CreatedAt = creationTS

	// Calculating Age in days since the cluster was created until last scraping
	newAge := calculateAge(c.CreatedAt, c.LastScanTS)
	if c.Age > newAge && c.Age != 0 {
		return fmt.Errorf("New cluster age is lower than previous value. Current age: %d, New estimated age: %d", c.Age, newAge)
	}

	c.Age = newAge
	return nil
}

// UpdateStatus evaluate the status of the cluster checking how many of the
// nodes are in Running, Stopped or Terminated status.
// Logic rules:
// - Empty cluster (no instances) -> Terminated
// - Any instance Running -> Running (early return)
// - All instances Terminated -> Terminated
// - Otherwise (mix of Stopped/Terminated or all Stopped) -> Stopped
func (c *Cluster) UpdateStatus() {
	instanceCount := len(c.Instances)

	// TODO. Possible edge case
	if instanceCount == 0 {
		c.Status = Terminated
		return
	}

	terminatedCount := 0
	for _, instance := range c.Instances {
		if instance.Status == Running {
			c.Status = Running
			return
		} else if instance.Status == Terminated {
			terminatedCount++
		}
	}

	if terminatedCount == instanceCount {
		c.Status = Terminated
	} else {
		c.Status = Stopped
	}
}

// IsInstanceInCluster checks if an instance is already in the Cluster
func (c Cluster) IsInstanceInCluster(instance *Instance) bool {
	return slices.ContainsFunc(c.Instances, func(i Instance) bool {
		return i.InstanceID == i.InstanceID
	})
}

// AddInstance add a new instance to a cluster
func (c *Cluster) AddInstance(instance *Instance) error {
	if c.IsInstanceInCluster(instance) {
		return fmt.Errorf("Instance '%s[%s]' already exists in Cluster %s", instance.ClusterID, instance.InstanceID, c.ClusterName)
	}

	// Updating owner cluster
	instance.Cluster = c

	// Adding Instance
	c.Instances = append(c.Instances, *instance)
	return c.Update()
}

func (c *Cluster) DeleteInstance(instanceName string) error {
	for i, instance := range c.Instances {
		if instance.InstanceName == instanceName {
			// Removing owner cluster
			instance.Cluster = nil

			// Removing instance
			c.Instances = append(c.Instances[:i], c.Instances[i+1:]...)
			return nil
		}
	}

	return fmt.Errorf("failed to delete Instance(%s) from Cluster(%s). Instance not found", instanceName, c.ClusterName)
}

func (c Cluster) InstancesCount() int {
	return len(c.Instances)
}

// Obtain the required parameters for generate a ClusterID. If any key parameter is missing, it will return a non-nil error
func generateClusterID(name string, infraID string) string {
	return name + "-" + infraID
}

// PrintCluster prints cluster info
func (c Cluster) PrintCluster() {
	fmt.Printf("\t\tCluster:[%s] -- Region: %s, Provider: %s, #Instances: %d\n", c.ClusterName, c.Region, c.Provider, c.InstancesCount())

	for _, instance := range c.Instances {
		instance.PrintInstance()
	}
}
