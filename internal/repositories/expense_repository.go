// THIS FILE IS AUTOGENERATED. DO NOT EDIT.

package repositories

import (
	"context"
	"fmt"

	"github.com/RHEcosystemAppEng/cluster-iq/internal/inventory"
	"github.com/jmoiron/sqlx"
)

var _ ExpenseRepository = (*expenseRepositoryImpl)(nil)

// ExpenseRepository defines the interface for data access operations for expenses.
type ExpenseRepository interface {
	ListExpenses(ctx context.Context, opts ListOptions) ([]inventory.Expense, int, error)
	GetExpensesByInstance(ctx context.Context, instanceID string) ([]inventory.Expense, error)
	WriteExpenses(ctx context.Context, expenses []inventory.Expense) error
}

type expenseRepositoryImpl struct {
	db *sqlx.DB
}

func NewExpenseRepository(db *sqlx.DB) ExpenseRepository {
	return &expenseRepositoryImpl{db: db}
}

// ListExpenses retrieves all expenses from the database.
//
// Parameters:
//
// Returns:
// - A slice of inventory.Expense objects.
// - An error if the query fails.
func (r *expenseRepositoryImpl) ListExpenses(ctx context.Context, opts ListOptions) ([]inventory.Expense, int, error) {
	var expenses []inventory.Expense
	baseQuery := SelectExpensesQuery
	countQuery := "SELECT COUNT(*) FROM expenses"

	whereClauses, namedArgs := buildExpenseWhereClauses(opts.Filters)

	total, err := listQueryHelper(ctx, r.db, &expenses, baseQuery, countQuery, opts, whereClauses, namedArgs)
	if err != nil {
		return nil, 0, fmt.Errorf("failed to list expenses: %w", err)
	}
	return expenses, total, nil
}

// GetExpensesByInstance retrieves expenses for a specific instance.
//
// Parameters:
// - instanceID: The ID of the instance.
//
// Returns:
// - A slice of inventory.Expense objects associated with the instance.
// - An error if the query fails.
func (r *expenseRepositoryImpl) GetExpensesByInstance(ctx context.Context, instanceID string) ([]inventory.Expense, error) {
	var expenses []inventory.Expense
	if err := r.db.SelectContext(ctx, &expenses, SelectExpensesByInstanceQuery, instanceID); err != nil {
		return nil, fmt.Errorf("failed to get expenses for instance %s: %w", instanceID, err)
	}
	return expenses, nil
}

// WriteExpenses writes a batch of expenses to the database in a transaction.
//
// Parameters:
// - expenses: A slice of inventory.Expense objects to insert.
//
// Returns:
// - An error if the transaction fails.
func (r *expenseRepositoryImpl) WriteExpenses(ctx context.Context, expenses []inventory.Expense) error {
	tx, err := r.db.BeginTxx(ctx, nil)
	if err != nil {
		return fmt.Errorf("failed to begin transaction: %w", err)
	}
	defer tx.Rollback()

	// Writing Expenses
	if _, err := tx.NamedExecContext(ctx, InsertExpensesQuery, expenses); err != nil {

		return fmt.Errorf("failed to execute insert expenses query: %w", err)
	}

	// Commit
	return tx.Commit()
}

func buildExpenseWhereClauses(filters map[string]interface{}) ([]string, map[string]interface{}) {
	clauses := make([]string, 0, len(filters))
	args := make(map[string]interface{})

	for key, value := range filters {
		switch key {
		case "instance_id":
			clauses = append(clauses, "instance_id = :instance_id")
			args["instance_id"] = value
		}
	}

	return clauses, args
}
