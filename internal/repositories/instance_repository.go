// THIS FILE IS AUTOGENERATED. DO NOT EDIT.

package repositories

import (
	"context"
	"fmt"

	"github.com/RHEcosystemAppEng/cluster-iq/internal/inventory"
	"github.com/jmoiron/sqlx"
)

var _ InstanceRepository = (*instanceRepositoryImpl)(nil)

// InstanceRepository defines the interface for data access operations for instances.
type InstanceRepository interface {
	ListInstances(ctx context.Context, opts ListOptions) ([]inventory.Instance, int, error)
	GetInstancesOverview(ctx context.Context) (inventory.InstancesSummary, error)
	GetInstanceByID(ctx context.Context, instanceID string) (inventory.Instance, error)
	WriteInstances(ctx context.Context, instances []inventory.Instance) error
	DeleteInstance(ctx context.Context, instanceID string) error
	GetInstancesOutdatedBilling(ctx context.Context) ([]inventory.Instance, error)
}

type instanceRepositoryImpl struct {
	db *sqlx.DB
}

func NewInstanceRepository(db *sqlx.DB) InstanceRepository {
	return &instanceRepositoryImpl{db: db}
}

// ListInstances retrieves all instances from the database and maps them to inventory.Instance objects.
//
// Returns:
// - A slice of inventory.Instance objects.
// - An error if the query fails.
func (r *instanceRepositoryImpl) ListInstances(ctx context.Context, opts ListOptions) ([]inventory.Instance, int, error) {
	var instances []inventory.Instance
	baseQuery := SelectInstancesQuery
	countQuery := "SELECT COUNT(*) FROM instances"

	whereClauses, namedArgs := buildInstanceWhereClauses(opts.Filters)

	total, err := listQueryHelper(ctx, r.db, &instances, baseQuery, countQuery, opts, whereClauses, namedArgs)
	if err != nil {
		return nil, 0, fmt.Errorf("failed to list instances: %w", err)
	}

	return instances, total, nil
}

// GetInstancesOverview returns a summary of instances grouped by their status.
// It provides the total count along with counts of running and stopped instances.
func (r *instanceRepositoryImpl) GetInstancesOverview(ctx context.Context) (inventory.InstancesSummary, error) {
	var instances inventory.InstancesSummary
	if err := r.db.GetContext(ctx, &instances, SelectInstancesOverview); err != nil {
		return inventory.InstancesSummary{}, err
	}

	return instances, nil
}

// GetInstanceByID retrieves an instance by its ID.
//
// Parameters:
// - instanceID: The ID of the instance to retrieve.
//
// Returns:
// - An inventory.Instance object.
// - An error if the query fails.
func (r *instanceRepositoryImpl) GetInstanceByID(ctx context.Context, instanceID string) (inventory.Instance, error) {
	var instance inventory.Instance
	// Assuming the query joins tags appropriately.
	if err := r.db.GetContext(ctx, &instance, SelectInstancesByIDQuery, instanceID); err != nil {
		return inventory.Instance{}, fmt.Errorf("failed to get instance by id %s: %w", instanceID, err)
	}

	return instance, nil
}

// WriteInstances writes a batch of instances and their tags to the database in a transaction.
//
// Parameters:
// - instances: A slice of inventory.Instance objects to insert.
//
// Returns:
// - An error if the transaction fails.
func (r *instanceRepositoryImpl) WriteInstances(ctx context.Context, instances []inventory.Instance) error {
	tx, err := r.db.BeginTxx(ctx, nil)
	if err != nil {
		return fmt.Errorf("failed to begin transaction: %w", err)
	}
	defer tx.Rollback()

	instanceStmt, err := tx.PrepareNamedContext(ctx, InsertInstancesQuery)
	if err != nil {
		return fmt.Errorf("failed to prepare insert instances statement: %w", err)
	}
	defer instanceStmt.Close()

	tagStmt, err := tx.PrepareNamedContext(ctx, InsertTagsQuery)
	if err != nil {
		return fmt.Errorf("failed to prepare insert tags statement: %w", err)
	}
	defer tagStmt.Close()

	for _, instance := range instances {
		if _, err := instanceStmt.ExecContext(ctx, instance); err != nil {

			return fmt.Errorf("failed to insert instance %s: %w", instance.ID, err)
		}

		// Writing tags
		for _, tag := range instance.Tags {
			if _, err := tagStmt.ExecContext(ctx, tag); err != nil {

				return fmt.Errorf("failed to insert tag for instance %s: %w", instance.ID, err)
			}
		}
	}

	// Commit the transaction
	return tx.Commit()
}

// DeleteInstance deletes an instance and its associated tags from the database.
//
// Parameters:
// - instanceID: The ID of the instance to delete.
//
// Returns:
// - An error if the transaction fails.
func (r *instanceRepositoryImpl) DeleteInstance(ctx context.Context, instanceID string) error {
	tx, err := r.db.BeginTxx(ctx, nil)
	if err != nil {
		return fmt.Errorf("failed to begin transaction: %w", err)
	}
	defer tx.Rollback()

	if _, err := tx.ExecContext(ctx, DeleteTagsQuery, instanceID); err != nil {
		return fmt.Errorf("failed to delete tags for instance %s: %w", instanceID, err)
	}
	if _, err := tx.ExecContext(ctx, DeleteInstanceQuery, instanceID); err != nil {
		return fmt.Errorf("failed to delete instance %s: %w", instanceID, err)
	}

	// Commit the transaction
	return tx.Commit()
}

// GetInstancesOutdatedBilling retrieves instances with outdated billing information.
//
// Parameters:
//
// Returns:
// - A slice of inventory.Instance objects.
// - An error if the query fails.
func (r *instanceRepositoryImpl) GetInstancesOutdatedBilling(ctx context.Context) ([]inventory.Instance, error) {
	var instances []inventory.Instance
	if err := r.db.SelectContext(ctx, &instances, SelectLastExpensesQuery); err != nil {
		return nil, fmt.Errorf("failed to get instances with outdated billing: %w", err)
	}

	return instances, nil
}

func buildInstanceWhereClauses(filters map[string]interface{}) ([]string, map[string]interface{}) {
	clauses := make([]string, 0, len(filters))
	args := make(map[string]interface{})

	for key, value := range filters {
		switch key {
		case "id":
			clauses = append(clauses, "id = :id")
			args["id"] = value
		case "provider":
			clauses = append(clauses, "provider = :provider")
			args["provider"] = value
		case "instance_type":
			clauses = append(clauses, "instance_type = :instance_type")
			args["instance_type"] = value
		case "availability_zone":
			clauses = append(clauses, "availability_zone = :availability_zone")
			args["availability_zone"] = value
		case "cluster_id":
			clauses = append(clauses, "cluster_id = :cluster_id")
			args["cluster_id"] = value
		case "status":
			clauses = append(clauses, "status = :status")
			args["status"] = value
		}
	}

	return clauses, args
}
