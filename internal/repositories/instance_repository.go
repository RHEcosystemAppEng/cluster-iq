// THIS FILE IS AUTOGENERATED. DO NOT EDIT.

package repositories

import (
	"context"
	"database/sql"
	"errors"
	"fmt"

	"github.com/RHEcosystemAppEng/cluster-iq/internal/inventory"
	"github.com/jmoiron/sqlx"
)

var _ InstanceRepository = (*instanceRepositoryImpl)(nil)

// InstanceRepository defines the interface for data access operations for instances.
type InstanceRepository interface {
	ListInstances(ctx context.Context, opts ListOptions) ([]inventory.Instance, int, error)
	GetInstancesOverview(ctx context.Context) (inventory.InstancesSummary, error)
	GetInstanceByID(ctx context.Context, instanceID string) (*inventory.Instance, error)
	CreateInstances(ctx context.Context, instances []inventory.Instance) error
	DeleteInstance(ctx context.Context, instanceID string) error
	GetInstancesOutdatedBilling(ctx context.Context) ([]inventory.Instance, error)
}

type instanceRepositoryImpl struct {
	db *sqlx.DB
}

func NewInstanceRepository(db *sqlx.DB) InstanceRepository {
	return &instanceRepositoryImpl{db: db}
}

// ListInstances retrieves all instances from the database and maps them to inventory.Instance objects.
//
// Returns:
// - A slice of inventory.Instance objects.
// - An error if the query fails.
func (r *instanceRepositoryImpl) ListInstances(ctx context.Context, opts ListOptions) ([]inventory.Instance, int, error) {
	var instances []inventory.Instance
	baseQuery := SelectInstancesQuery
	countQuery := "SELECT COUNT(*) FROM instances"

	whereClauses, namedArgs := buildInstanceWhereClauses(opts.Filters)

	total, err := listQueryHelper(ctx, r.db, &instances, baseQuery, countQuery, opts, whereClauses, namedArgs)
	if err != nil {
		return nil, 0, fmt.Errorf("failed to list instances: %w", err)
	}

	if len(instances) == 0 {
		return instances, total, nil
	}

	// Get Tags for the instances
	instanceIDs := make([]string, len(instances))
	for i, inst := range instances {
		instanceIDs[i] = inst.ID
	}

	query, args, err := sqlx.In(SelectTagsByInstanceIDsQuery, instanceIDs)
	if err != nil {
		return nil, 0, fmt.Errorf("failed to create IN query for tags: %w", err)
	}

	query = r.db.Rebind(query)
	var tags []inventory.Tag
	if err := r.db.SelectContext(ctx, &tags, query, args...); err != nil {
		return nil, 0, fmt.Errorf("failed to select tags for instances: %w", err)
	}

	// Map tags to instances
	tagMap := make(map[string][]inventory.Tag)
	for _, tag := range tags {
		tagMap[tag.InstanceID] = append(tagMap[tag.InstanceID], tag)
	}

	for i := range instances {
		if tags, ok := tagMap[instances[i].ID]; ok {
			instances[i].Tags = tags
		}
	}

	return instances, total, nil
}

// GetInstancesOverview returns a summary of instances grouped by their status.
// It provides the total count along with counts of running and stopped instances.
func (r *instanceRepositoryImpl) GetInstancesOverview(ctx context.Context) (inventory.InstancesSummary, error) {
	var instances inventory.InstancesSummary
	if err := r.db.GetContext(ctx, &instances, SelectInstancesOverview); err != nil {
		return inventory.InstancesSummary{}, err
	}

	return instances, nil
}

// GetInstanceByID retrieves an instance by its ID.
//
// Parameters:
// - instanceID: The ID of the instance to retrieve.
//
// Returns:
// - An inventory.Instance object.
// - An error if the query fails.
func (r *instanceRepositoryImpl) GetInstanceByID(ctx context.Context, instanceID string) (*inventory.Instance, error) {
	var instance inventory.Instance
	if err := r.db.GetContext(ctx, &instance, SelectInstancesByIDQuery, instanceID); err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, ErrNotFound
		}
		return nil, fmt.Errorf("failed to get instance by id %s: %w", instanceID, err)
	}

	var tags []inventory.Tag
	if err := r.db.SelectContext(ctx, &tags, SelectTagsByInstanceIDQuery, instanceID); err != nil {
		// Not finding tags is not a critical error, just return the instance without them
		return &instance, nil
	}
	instance.Tags = tags

	return &instance, nil
}

// CreateInstances writes a batch of instances and their tags to the database in a transaction.
//
// Parameters:
// - instances: A slice of inventory.Instance objects to insert.
//
// Returns:
// - An error if the transaction fails.
func (r *instanceRepositoryImpl) CreateInstances(ctx context.Context, instances []inventory.Instance) error {
	tx, err := r.db.BeginTxx(ctx, nil)
	if err != nil {
		return fmt.Errorf("failed to begin transaction: %w", err)
	}
	defer tx.Rollback()

	instanceStmt, err := tx.PrepareNamedContext(ctx, InsertInstancesQuery)
	if err != nil {
		return fmt.Errorf("failed to prepare insert instances statement: %w", err)
	}
	defer instanceStmt.Close()

	tagStmt, err := tx.PrepareNamedContext(ctx, InsertTagsQuery)
	if err != nil {
		return fmt.Errorf("failed to prepare insert tags statement: %w", err)
	}
	defer tagStmt.Close()

	for _, instance := range instances {
		if _, err := instanceStmt.ExecContext(ctx, instance); err != nil {
			return fmt.Errorf("failed to insert instance %s: %w", instance.ID, err)
		}

		// Writing tags
		for _, tag := range instance.Tags {
			if _, err := tagStmt.ExecContext(ctx, tag); err != nil {
				return fmt.Errorf("failed to insert tag for instance %s: %w", instance.ID, err)
			}
		}
	}

	// Commit the transaction
	return tx.Commit()
}

// DeleteInstance deletes an instance and its associated tags from the database.
//
// Parameters:
// - instanceID: The ID of the instance to delete.
//
// Returns:
// - An error if the transaction fails.
func (r *instanceRepositoryImpl) DeleteInstance(ctx context.Context, instanceID string) error {
	tx, err := r.db.BeginTxx(ctx, nil)
	if err != nil {
		return fmt.Errorf("failed to begin transaction: %w", err)
	}
	defer tx.Rollback()

	if _, err := tx.ExecContext(ctx, DeleteTagsQuery, instanceID); err != nil {
		return fmt.Errorf("failed to delete tags for instance %s: %w", instanceID, err)
	}
	if _, err := tx.ExecContext(ctx, DeleteInstanceQuery, instanceID); err != nil {
		return fmt.Errorf("failed to delete instance %s: %w", instanceID, err)
	}

	// Commit the transaction
	return tx.Commit()
}

// GetInstancesOutdatedBilling retrieves instances with outdated billing information.
//
// Parameters:
//
// Returns:
// - A slice of inventory.Instance objects.
// - An error if the query fails.
func (r *instanceRepositoryImpl) GetInstancesOutdatedBilling(ctx context.Context) ([]inventory.Instance, error) {
	var instances []inventory.Instance
	if err := r.db.SelectContext(ctx, &instances, SelectLastExpensesQuery); err != nil {
		return nil, fmt.Errorf("failed to get instances with outdated billing: %w", err)
	}

	return instances, nil
}

func buildInstanceWhereClauses(filters map[string]interface{}) ([]string, map[string]interface{}) {
	clauses := make([]string, 0, len(filters))
	args := make(map[string]interface{})

	for key, value := range filters {
		switch key {
		case "cluster_id":
			clauses = append(clauses, "cluster_id = :cluster_id")
			args["cluster_id"] = value
		case "status":
			clauses = append(clauses, "status = :status")
			args["status"] = value
		}
	}

	return clauses, args
}
