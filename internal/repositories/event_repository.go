// THIS FILE IS AUTOGENERATED. DO NOT EDIT.

package repositories

import (
	"context"
	"fmt"

	"github.com/RHEcosystemAppEng/cluster-iq/internal/audit"
	"github.com/jmoiron/sqlx"
)

var _ EventRepository = (*eventRepositoryImpl)(nil)

// EventRepository defines the interface for data access operations for events.
type EventRepository interface {
	ListSystemEvents(ctx context.Context, opts ListOptions) ([]audit.SystemAuditLogs, int, error)
	ListClusterEvents(ctx context.Context, opts ListOptions) ([]audit.AuditLog, int, error)
	AddEvent(ctx context.Context, event audit.AuditLog) (int64, error)
	UpdateEventStatus(ctx context.Context, eventID int64, result string) error
}

type eventRepositoryImpl struct {
	db *sqlx.DB
}

func NewEventRepository(db *sqlx.DB) EventRepository {
	return &eventRepositoryImpl{db: db}
}

// ListSystemEvents retrieves system-wide events with extended metadata.
func (r *eventRepositoryImpl) ListSystemEvents(ctx context.Context, opts ListOptions) ([]audit.SystemAuditLogs, int, error) {
	var events []audit.SystemAuditLogs
	baseQuery := SelectSystemEventsQuery
	countQuery := "SELECT COUNT(*) FROM audit_logs"

	whereClauses, namedArgs := buildEventWhereClauses(opts.Filters)

	total, err := listQueryHelper(ctx, r.db, &events, baseQuery, countQuery, opts, whereClauses, namedArgs)
	if err != nil {
		return nil, 0, fmt.Errorf("failed to list system events: %w", err)
	}

	return events, total, nil
}

// ListClusterEvents retrieves events for a specific resource (like a cluster).
func (r *eventRepositoryImpl) ListClusterEvents(ctx context.Context, opts ListOptions) ([]audit.AuditLog, int, error) {
	var events []audit.AuditLog
	baseQuery := SelectClusterEventsQuery
	countQuery := "SELECT COUNT(*) FROM audit_logs"

	whereClauses, namedArgs := buildEventWhereClauses(opts.Filters)

	total, err := listQueryHelper(ctx, r.db, &events, baseQuery, countQuery, opts, whereClauses, namedArgs)
	if err != nil {
		return nil, 0, fmt.Errorf("failed to list cluster events: %w", err)
	}

	return events, total, nil
}

// AddEvent inserts a new audit event into the database and returns the event ID.
func (r *eventRepositoryImpl) AddEvent(ctx context.Context, event audit.AuditLog) (int64, error) {
	stmt, err := r.db.PrepareNamedContext(ctx, InsertEventQuery)
	if err != nil {
		return 0, fmt.Errorf("failed to prepare insert event query: %w", err)
	}
	defer stmt.Close()

	var id int64
	if err := stmt.GetContext(ctx, &id, event); err != nil {
		return 0, fmt.Errorf("failed to execute insert event statement: %w", err)
	}

	return id, nil
}

// UpdateEventStatus updates the result status of an audit event.
func (r *eventRepositoryImpl) UpdateEventStatus(ctx context.Context, eventID int64, result string) error {
	_, err := r.db.ExecContext(ctx, UpdateEventStatusQuery, result, eventID)
	if err != nil {
		return fmt.Errorf("failed to update event status for event %d: %w", eventID, err)
	}
	return nil
}

// buildEventWhereClauses builds the where clauses for the event repository.
// TODO: REVIEW
func buildEventWhereClauses(filters map[string]interface{}) ([]string, map[string]interface{}) {
	clauses := make([]string, 0, len(filters))
	args := make(map[string]interface{})

	for key, value := range filters {
		switch key {
		case "triggered_by":
			clauses = append(clauses, "triggered_by = :triggered_by")
			args["triggered_by"] = value
		case "action_name":
			clauses = append(clauses, "action_name = :action_name")
			args["action_name"] = value
		case "resource_id":
			clauses = append(clauses, "resource_id = :resource_id")
			args["resource_id"] = value
		case "resource_type":
			clauses = append(clauses, "resource_type = :resource_type")
			args["resource_type"] = value
		case "result":
			clauses = append(clauses, "result = :result")
			args["result"] = value
		case "severity":
			clauses = append(clauses, "severity = :severity")
			args["severity"] = value
		}
	}

	return clauses, args
}
