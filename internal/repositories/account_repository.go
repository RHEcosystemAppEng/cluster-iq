// THIS FILE IS AUTOGENERATED. DO NOT EDIT.

package repositories

import (
	"context"
	"database/sql"
	"errors"
	"fmt"

	"github.com/RHEcosystemAppEng/cluster-iq/internal/inventory"
	"github.com/jmoiron/sqlx"
)

var _ AccountRepository = (*accountRepositoryImpl)(nil)

// AccountRepository defines the interface for data access operations for accounts.
type AccountRepository interface {
	DeleteAccount(ctx context.Context, accountName string) error
	GetAccountByName(ctx context.Context, accountName string) (*inventory.Account, error)
	ListAccounts(ctx context.Context, opts ListOptions) ([]inventory.Account, int, error)
	WriteAccounts(ctx context.Context, accounts []inventory.Account) error
}

type accountRepositoryImpl struct {
	db *sqlx.DB
}

func NewAccountRepository(db *sqlx.DB) AccountRepository {
	return &accountRepositoryImpl{db: db}
}

// ListAccounts retrieves all accounts from the database.
//
// Returns:
// - A slice of inventory.Account objects.
// - An error if the query fails.
func (r *accountRepositoryImpl) ListAccounts(ctx context.Context, opts ListOptions) ([]inventory.Account, int, error) {
	var accounts []inventory.Account
	baseQuery := SelectAccountsQuery
	countQuery := "SELECT COUNT(*) FROM accounts"

	whereClauses, namedArgs := buildAccountWhereClauses(opts.Filters)
	total, err := listQueryHelper(ctx, r.db, &accounts, baseQuery, countQuery, opts, whereClauses, namedArgs)
	if err != nil {
		return nil, 0, fmt.Errorf("failed to list accounts: %w", err)
	}

	return accounts, total, nil
}

// GetAccountByName retrieves an account by its name from the database.
//
// Parameters:
// - accountName: The name of the account to retrieve.
//
// Returns:
// - A slice of inventory.Account objects (usually containing one element).
// - An error if the query fails.
func (r *accountRepositoryImpl) GetAccountByName(ctx context.Context, accountName string) (*inventory.Account, error) {
	var account inventory.Account
	err := r.db.GetContext(ctx, &account, SelectAccountByNameQuery, accountName)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, ErrNotFound
		}
		return nil, err
	}
	return &account, nil
}

// WriteAccounts inserts multiple accounts into the database in a transaction.
//
// Parameters:
// - accounts: A slice of inventory.Account objects to insert.
//
// Returns:
// - An error if the transaction fails.
func (r *accountRepositoryImpl) WriteAccounts(ctx context.Context, accounts []inventory.Account) error {
	tx, err := r.db.BeginTxx(ctx, nil)
	if err != nil {
		return fmt.Errorf("failed to begin transaction: %w", err)
	}
	defer tx.Rollback()

	if _, err = tx.NamedExecContext(ctx, InsertAccountsQuery, accounts); err != nil {
		// r.logger.Error("Failed to prepare InsertAccountsQuery query", zap.Error(err))
		return fmt.Errorf("failed to execute insert accounts query: %w", err)
	}
	return tx.Commit()
}

// DeleteAccount deletes an account from the database by its name.
//
// Parameters:
// - accountName: The name of the account to delete.
//
// Returns:
// - An error if the transaction fails.
func (r *accountRepositoryImpl) DeleteAccount(ctx context.Context, accountName string) error {
	tx, err := r.db.BeginTxx(ctx, nil)
	if err != nil {
		return fmt.Errorf("failed to begin transaction: %w", err)
	}
	defer tx.Rollback()

	if _, err := tx.ExecContext(ctx, DeleteAccountQuery, accountName); err != nil {
		return fmt.Errorf("failed to delete account %s: %w", accountName, err)
	}

	return tx.Commit()
}

func buildAccountWhereClauses(filters map[string]interface{}) ([]string, map[string]interface{}) {
	clauses := make([]string, 0, len(filters))
	args := make(map[string]interface{})

	for key, value := range filters {
		switch key {
		case "provider":
			clauses = append(clauses, "provider = :provider")
			args["provider"] = value
		case "name":
			clauses = append(clauses, "name = :name")
			args["name"] = value
		case "id":
			clauses = append(clauses, "id = :id")
			args["id"] = value
		}
	}

	return clauses, args
}
