package dbclient

import (
	"database/sql"
	"fmt"
	"strings"
	"time"

	"github.com/RHEcosystemAppEng/cluster-iq/internal/actions"
	"github.com/RHEcosystemAppEng/cluster-iq/internal/inventory"
	"github.com/RHEcosystemAppEng/cluster-iq/internal/models"
	"go.uber.org/zap"
)

// DisableScheduledAction Disables an Action by its ID
//
// Parameters:
//   - Action ID
//
// Returns:
//   - An array of actions.ScheduledAction with the scheduled actions declared on the DB that are enabled
//   - An error if the query fails
func (a DBClient) DisableScheduledAction(actionID string) error {
	// Begin transaction
	tx, err := a.db.Beginx()
	if err != nil {
		return err
	}

	defer func() {
		if err != nil {
			if rbErr := tx.Rollback(); rbErr != nil {
				a.logger.Error("Failed to rollback DisableScheduledAction transaction", zap.Error(rbErr))
			}
		}
	}()

	// Writing Scheduled Actions
	if _, err := tx.Exec(DisableActionQuery, actionID); err != nil {
		a.logger.Error("Failed to prepare DisableScheduledAction query", zap.Error(err))
		return err
	}

	// Commit the transaction
	if err := tx.Commit(); err != nil {
		return err
	}
	return nil
}

// GetScheduledActionByID runs the db select query for retrieving a specific scheduled action by its ID
//
// Parameters:
//
// Returns:
//   - An array of actions.ScheduledAction with the scheduled actions declared on
//     the DB. It's expected to return an array with a single element, but still
//     being an array for code compatibility
//   - An error if the query fails
func (a DBClient) GetScheduledActionByID(actionID string) ([]actions.Action, error) {
	// Getting results from DB
	var dbresult []models.DBScheduledAction
	if err := a.db.Select(&dbresult, SelectScheduledActionsByIDQuery, actionID); err != nil {
		a.logger.Error("Failed to prepare SelectScheduledActions query", zap.Error(err))
		return nil, err
	}

	// Transform from DBScheduledAction to ScheduledAction
	return models.FromDBScheduledActionToActions(dbresult), nil
}

// WriteScheduledActions receives an array of actions.ScheduledAction and writes them on the DB
//
// Parameters:
//   - An array of actions.ScheduledAction to write on the DB
//
// Returns:
//   - An error if the insert fails
func (a DBClient) WriteScheduledActions(newActions []actions.Action) error {
	// Begin transaction
	tx, err := a.db.Beginx()
	if err != nil {
		return err
	}

	defer func() {
		if err != nil {
			if rbErr := tx.Rollback(); rbErr != nil {
				a.logger.Error("Failed to rollback WriteScheduledActions transaction", zap.Error(rbErr))
			}
		}
	}()

	schedActions, cronActions := actions.SplitActionsByType(newActions)

	// Writing Scheduled Actions
	if len(schedActions) > 0 {
		if _, err := tx.NamedExec(InsertScheduledActionsQuery, schedActions); err != nil {
			a.logger.Error("Failed to prepare InsertScheduledActionsQuery query", zap.Error(err))
			return err
		}
	}

	// Writing Cron Actions
	if len(cronActions) > 0 {
		if _, err := tx.NamedExec(InsertCronActionsQuery, cronActions); err != nil {
			a.logger.Error("Failed to prepare InsertCronActionsQuery query", zap.Error(err))
			return err
		}
	}

	// Commit the transaction
	if err := tx.Commit(); err != nil {
		return err
	}
	return nil
}

// PatchScheduledAction updates Action by its ID
//
// Parameters:
//   - Action list
//
// Returns:
//   - An error if the query fails
func (a DBClient) PatchScheduledAction(newActions []actions.Action) error {
	// Begin transaction
	tx, err := a.db.Beginx()
	if err != nil {
		return err
	}
	defer func() {
		if err != nil {
			if rbErr := tx.Rollback(); rbErr != nil {
				a.logger.Error("Failed to rollback PatchScheduledAction query", zap.Error(rbErr))
			}
		}
	}()
	schedActions, cronActions := actions.SplitActionsByType(newActions)

	// Writing Scheduled Actions
	if len(schedActions) > 0 {
		if _, err := tx.NamedExec(PatchScheduledActionsQuery, schedActions); err != nil {
			a.logger.Error("Failed to prepare PatchScheduledAction query", zap.Error(err))
			return err
		}
	}

	// Writing Cron Actions
	if len(cronActions) > 0 {
		if _, err := tx.NamedExec(PatchCronActionsQuery, cronActions); err != nil {
			a.logger.Error("Failed to prepare PatchCronActionsQuery query", zap.Error(err))
			return err
		}
	}

	// Commit the transaction
	if err := tx.Commit(); err != nil {
		return err
	}
	return nil
}

// PatchScheduledActionStatus updates Action status by its ID
//
// Parameters:
//   - Action list
//
// Returns:
//   - An error if the query fails
func (a DBClient) PatchScheduledActionStatus(actionID string, status string) error {
	// Begin transaction
	tx, err := a.db.Beginx()
	if err != nil {
		return err
	}

	defer func() {
		if err != nil {
			if rbErr := tx.Rollback(); rbErr != nil {
				a.logger.Error("Failed to rollback PatchScheduledActionStatus query", zap.Error(rbErr))
			}
		}
	}()

	enabled := status == "Pending"

	if _, err := tx.Exec(PatchActionStatusQuery, actionID, status, enabled); err != nil {
		a.logger.Error("Failed to prepare PatchScheduledActionStatus query", zap.Error(err))
		return err
	}

	// Commit the transaction
	if err := tx.Commit(); err != nil {
		return err
	}
	return nil
}

// DeleteScheduledAction removes an actions.ScheduledAction action from the DB based on its ID
//
// Parameters:
//   - A string containing the action ID to be removed
//
// Returns:
//   - An error if the delete query fails
func (a DBClient) DeleteScheduledAction(actionID string) error {
	// Begin transaction
	tx, err := a.db.Beginx()
	if err != nil {
		return err
	}

	defer func() {
		if err != nil {
			if rbErr := tx.Rollback(); rbErr != nil {
				a.logger.Error("Failed to rollback DeleteScheduledAction query", zap.Error(rbErr))
			}
		}
	}()

	// Deleting
	tx.MustExec(DeleteScheduledActionsQuery, actionID)

	// Commit the transaction
	if err := tx.Commit(); err != nil {
		return err
	}
	return nil
}

// GetExpenses retrieves all expenses from the database.
//
// Parameters:
//
// Returns:
// - A slice of inventory.Expense objects.
// - An error if the query fails.
func (a DBClient) GetExpenses() ([]inventory.Expense, error) {
	var dbexpenses []inventory.Expense
	if err := a.db.Select(&dbexpenses, SelectExpensesQuery); err != nil {
		return nil, err
	}

	return dbexpenses, nil
}

// GetInstancesOutdatedBilling retrieves instances with outdated billing information.
//
// Parameters:
//
// Returns:
// - A slice of inventory.Instance objects.
// - An error if the query fails.
func (a DBClient) GetInstancesOutdatedBilling() ([]inventory.Instance, error) {
	var dbexpenses []inventory.Instance
	if err := a.db.Select(&dbexpenses, SelectLastExpensesQuery); err != nil {
		return nil, err
	}

	return dbexpenses, nil
}

// GetExpensesByInstance retrieves expenses for a specific instance.
//
// Parameters:
// - instanceID: The ID of the instance.
//
// Returns:
// - A slice of inventory.Expense objects associated with the instance.
// - An error if the query fails.
func (a DBClient) GetExpensesByInstance(instanceID string) ([]inventory.Expense, error) {
	var dbexpenses []inventory.Expense
	if err := a.db.Select(&dbexpenses, SelectExpensesByInstanceQuery, instanceID); err != nil {
		return nil, err
	}

	return dbexpenses, nil
}

// WriteExpenses writes a batch of expenses to the database in a transaction.
//
// Parameters:
// - expenses: A slice of inventory.Expense objects to insert.
//
// Returns:
// - An error if the transaction fails.
func (a DBClient) WriteExpenses(expenses []inventory.Expense) error {
	tx, err := a.db.Beginx()
	if err != nil {
		return err
	}

	defer func() {
		if err != nil {
			if rbErr := tx.Rollback(); rbErr != nil {
				a.logger.Error("Failed to rollback WriteExpenses transaction", zap.Error(rbErr))
			}
		}
	}()

	// Writing Expenses
	if _, err := tx.NamedExec(InsertExpensesQuery, expenses); err != nil {
		a.logger.Error("Failed to prepare InsertExpensesQuery query", zap.Error(err), zap.Reflect("expenses", expenses))
		return err
	}

	// Commit
	if err := tx.Commit(); err != nil {
		return err
	}
	return nil
}

// GetInstancesOverview returns a summary of instances grouped by their status.
// It provides the total count along with counts of running and stopped instances.
func (a DBClient) GetInstancesOverview() (models.InstancesSummary, error) {
	var instances models.InstancesSummary
	if err := a.db.Get(&instances, SelectInstancesOverview); err != nil {
		return models.InstancesSummary{}, err
	}

	return instances, nil
}

// GetClustersOverview returns a summary of cluster statuses
// It counts the number of clusters that are running, stopped or terminated.
func (a DBClient) GetClustersOverview() (models.ClustersSummary, error) {
	var clustersOverview models.ClustersSummary
	if err := a.db.Get(&clustersOverview, SelectClustersOverview); err != nil {
		return models.ClustersSummary{}, err
	}
	return clustersOverview, nil
}

// GetProvidersOverview returns a summary of cloud providers (AWS, GCP, Azure) with
// their respective account and cluster counts.
func (a DBClient) GetProvidersOverview() (models.ProvidersSummary, error) {
	var providerRows []struct {
		Provider     string `db:"provider"`
		AccountCount int    `db:"account_count"`
		ClusterCount int    `db:"cluster_count"`
	}

	if err := a.db.Select(&providerRows, SelectProvidersOverviewQuery); err != nil {
		return models.ProvidersSummary{}, err
	}

	// Initialize the summary
	summary := models.ProvidersSummary{}

	// Map each provider to its proper field
	for _, row := range providerRows {
		detail := models.ProviderDetail{
			AccountCount: row.AccountCount,
			ClusterCount: row.ClusterCount,
		}

		switch strings.ToLower(row.Provider) {
		case "aws":
			summary.AWS = detail
		case "gcp":
			summary.GCP = detail
		case "azure":
			summary.Azure = detail
		}
	}

	return summary, nil
}

// RefreshInventory refreshes the database by updating the status of terminated instances and clusters.
//
// Returns:
// - An error if any update query fails.
func (a DBClient) RefreshInventory() error {
	tx, err := a.db.Beginx()
	if err != nil {
		return fmt.Errorf("failed to begin transaction: %w", err)
	}
	defer func() {
		if tx != nil {
			if rbErr := tx.Rollback(); rbErr != nil && rbErr != sql.ErrTxDone {
				a.logger.Error("Error during transaction rollback", zap.Error(rbErr))
			}
		}
	}()

	_, err = tx.Exec(UpdateTerminatedInstancesQuery)
	if err != nil {
		return fmt.Errorf("failed to refresh terminated instances: %w", err)
	}

	_, err = tx.Exec(UpdateTerminatedClustersQuery)
	if err != nil {
		return fmt.Errorf("failed to refresh terminated clusters: %w", err)
	}

	if err = tx.Commit(); err != nil {
		return fmt.Errorf("failed to commit transaction: %w", err)
	}

	return nil
}

// UpdateClusterStatusByClusterID updates the status of a cluster and all its instances in the database.
//
// This function first verifies if the requested status exists in the database. If the status is valid, it updates:
// 1. The status of the cluster identified by the given `clusterID`.
// 2. The status of all instances associated with the cluster.
//
// Parameters:
// - status: The new status to be applied to the cluster and its instances.
// - clusterID: The unique identifier of the cluster whose status will be updated.
//
// Returns:
// - An error if the status is invalid, the update operation fails, or no rows are affected.
func (a DBClient) UpdateClusterStatusByClusterID(status string, clusterID string) error {
	// Checking if the requested status is available on the DB
	if exists, err := a.CheckStatusValue(status); err != nil {
		return err
	} else if !exists {
		return fmt.Errorf("the requested status (%s) doesn't exist on the DB", status)
	}

	// Updating cluster status
	{
		var result sql.Result
		var err error
		var rows int64
		if result, err = a.db.Exec(UpdateStatusClusterByClusterIDQuery, status, clusterID); err != nil {
			return err
		}
		if rows, err = result.RowsAffected(); err != nil {
			return err
		}
		if rows == 0 {
			return fmt.Errorf("any cluster status was updated for ClusterID: %s", clusterID)
		}
		a.logger.Debug("Cluster status updated successfully", zap.String("cluster_id", clusterID))
	}

	// Updating cluster instances status
	{
		var result sql.Result
		var err error
		var rows int64
		if result, err = a.db.Exec(UpdateStatusInstancesByClusterIDQuery, status, clusterID); err != nil {
			return err
		}
		if rows, err = result.RowsAffected(); err != nil {
			return err
		}
		if rows == 0 {
			return fmt.Errorf("any instance status was updated for ClusterID: %s", clusterID)
		}
		a.logger.Debug("Instances status updated successfully", zap.String("cluster_id", clusterID))
	}

	return nil
}

// CheckStatusValue checks if a given status value exists in the database.
//
// Parameters:
// - status: The status value to check in the database.
//
// Returns:
// - A boolean indicating whether the status exists (true) or not (false).
// - An error if the query fails.
func (a DBClient) CheckStatusValue(status string) (bool, error) {
	var exists bool
	if err := a.db.QueryRow(CheckStatusQuery, status).Scan(&exists); err != nil {
		return false, err
	}
	return exists, nil
}

// GetScannerLastScanTimestamp returns the latest scan timestamp across all accounts
func (a DBClient) GetScannerLastScanTimestamp() (*time.Time, error) {
	var lastScanTimestamp sql.NullTime
	if err := a.db.Get(&lastScanTimestamp, SelectScannerLastScanTimestamp); err != nil {
		return nil, err
	}
	if lastScanTimestamp.Valid {
		return &lastScanTimestamp.Time, nil
	}
	return nil, nil
}
